{
    "benchmarks.CircStd.time_circ_std": {
        "code": "class CircStd:\n    def time_circ_std(self):\n        try:\n            data = np.random.randn(10000, 1000)\n            import numba\n    \n            def _circfunc(samples, high, low):\n                samples = np.asarray(samples)\n                if samples.size == 0:\n                    return np.nan, np.nan\n                return samples, _angle(samples, low, high, np.pi)\n    \n            @numba.vectorize(nopython=True)\n            def _angle(samples, low, high, pi=np.pi):\n                ang = (samples - low) * 2.0 * pi / (high - low)\n                return ang\n    \n            def _circular_standard_deviation(samples, high=2 * np.pi, low=0, axis=None):\n                pi = np.pi\n                samples, ang = _circfunc(samples, high, low)\n                S = np.sin(ang).mean(axis=axis)\n                C = np.cos(ang).mean(axis=axis)\n                R = np.hypot(S, C)\n                return ((high - low) / 2.0 / pi) * np.sqrt(-2 * np.log(R))\n    \n            return _circular_standard_deviation(data)\n        except ImportError:\n            data = np.random.randn(10000, 1000)\n            return circstd(data)",
        "min_run_count": 2,
        "name": "benchmarks.CircStd.time_circ_std",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "fc150f2fb365b98dd2c29ba2373d5e5aeb4ec572a8055b0afb727e3885eb101e",
        "warmup_time": -1
    },
    "benchmarks.Cov.time_numpy_cov": {
        "code": "class Cov:\n    def time_numpy_cov(self):\n        try:\n            data = np.random.randn(1000, 100)\n            import numba\n    \n            @numba.njit\n            def cov():\n                return np.cov(data)\n    \n        except ImportError:\n            data = np.random.randn(1000, 100)\n            return np.cov(data)",
        "min_run_count": 2,
        "name": "benchmarks.Cov.time_numpy_cov",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "4639a4b79f1e65b14f8e8afad42a5db72e90d0e664d065aa7606d0d81852dcf3",
        "warmup_time": -1
    },
    "benchmarks.Hist.time_histogram": {
        "code": "class Hist:\n    def time_histogram(self):\n        try:\n            data = np.random.rand(10000, 1000)\n            import numba\n    \n            @numba.njit(cache=True)\n            def _hist(data):\n                return np.histogram(data, bins=100)\n    \n            return _hist(data)\n        except ImportError:\n            data = np.random.rand(10000, 1000)\n            return np.histogram(data, bins=100)",
        "min_run_count": 2,
        "name": "benchmarks.Hist.time_histogram",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "71a2088037e8dc824eeb2bf47993c8626ebbecf237805834728200f63ccaee2a",
        "warmup_time": -1
    },
    "benchmarks.Stack.time_stack": {
        "code": "class Stack:\n    def time_stack(self):\n        try:\n            x = np.random.randn(10000, 1000)\n            y = np.random.randn(10000, 1000)\n            import numba\n    \n            @numba.njit\n            def stack(x, y):\n                return np.stack((x, y))\n    \n        except ImportError:\n            x = np.random.randn(10000, 1000)\n            y = np.random.randn(10000, 1000)\n            return np.stack((x, y))",
        "min_run_count": 2,
        "name": "benchmarks.Stack.time_stack",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "81ae81566d0448d4c574708e7b701944f37a475f6db559c8fa8360dc1bba4313",
        "warmup_time": -1
    },
    "benchmarks.Variance.time_variance": {
        "code": "class Variance:\n    def time_variance(self):\n        try:\n            data = np.random.randn(10000, 10000)\n            import numba\n    \n            @numba.njit(cache=True)\n            def stats_variance_1d(data, ddof=0):\n                a, b = 0, 0\n                for i in data:\n                    a = a + i\n                    b = b + i * i\n                var = b / (len(data)) - ((a / (len(data))) ** 2)\n                var = var * (len(data) / (len(data) - ddof))\n                return var\n    \n            def stats_variance_2d(data, ddof=0, axis=1):\n                a, b = data.shape\n                if axis == 1:\n                    var = np.zeros(a)\n                    for i in range(a):\n                        var[i] = stats_variance_1d(data[i], ddof=ddof)\n                else:\n                    var = np.zeros(b)\n                    for i in range(b):\n                        var[i] = stats_variance_1d(data[:, i], ddof=ddof)\n                return var\n    \n            return stats_variance_2d(data)\n        except ImportError:\n            data = np.random.randn(10000, 10000)\n            return np.var(data, axis=1)",
        "min_run_count": 2,
        "name": "benchmarks.Variance.time_variance",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "b116d3c6eeeb3757ace2bc027e6c1b229c900fe4a634597a4975f05b63edda53",
        "warmup_time": -1
    },
    "version": 2
}